
B或BL指令引起处理器转移到“子程序名”处开始执行。
两者的不同之处在于:
(1)BL指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。
      由于BL指令保存了下条指令的地址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。
(2)B指令则无法实现子程序的返回，只能实现单纯的跳转。

跳转指令用于实现程序流程的跳转，在 ARM 程序中有两种方法可以实现程序流程的跳转：
(1) 使用专门的跳转指令。
(2) 直接向程序计数器 PC 写入跳转地址值。

LDR指令的格式为：
LDR{条件}  目的寄存器，<存储器地址>
LDR指令用亍从存储器中将一个32位的字数据传送到目的寄存器中。

ARM指令集中，LDR通常都是作加载指令的，但是它也可以作伪指令。
LDR伪指令的形式是“LDR Rn,=expr”。

SP, the Stack Pointer
Register R13 is used as a pointer to the active stack.
LR, the Link Register
Register R14 is used to store the return address from a subroutine. 
r15:程序计数器，也称为pc寄存器。

ATPCS建议函数的形参不超过4个，如果形参个数少于或等于4，则形参由R0,R1,R2,R3四个寄存器进行传递；
若形参个数大于4，大于4的部分必须通过堆栈进行传递
r0-r3 函数传参
r4-r11 局部变量
函数结果返回规则
1.结果为一个32位的整数时,可以通过寄存器R0返回.
2.结果为一个64位整数时,可以通过R0和R1返回，依此类推.
3.结果为一个浮点数时,可以通过浮点运算部件的寄存器f0,d0或者s0来返回.
4.结果为一个复合的浮点数时,可以通过寄存器f0-fN或者d0~dN来返回.
5.对于位数更多的结果,需要通过调用内存来传递.

CMP比较指令，用于把一个寄存器的内容和另一个寄存器的内容或一个立即数进行比较，同时更新CPSR中条件标志位的值。
指令将第一操作数减去第二操作数，但不存储结果，只更改条件标志位。
CMP  R1, R0  ；做R1-R0的操作。
CMP  R1,#10  ；做R1-10的操作。

MOVEQ和MOVNE，分别是“MOVe (while) EQual”和“MOVe (while) Not Equal”的意思

MVN指令不同的是在传送之前，将被传送的对象先按位取反，再传送到目的寄存器。

堆栈是一种按特定顺序进行存取的存储区，这种特定顺序既是“先进后出”或“后进先出”。
堆栈寻址是隐含的，它使用一个专门的寄存器（堆栈指针）指向一块存储器区域。
栈指针所指定的存储单元就是堆栈的栈顶。堆栈可分为两种：
向上生长，又称递增堆栈，即地址向高地址方向生长。
向下生长，又称递减堆栈，即地址向低地址方向生长。
满堆栈，堆栈指针指向最后压入堆栈的有效数据项。
空堆栈，堆栈指针指向下一个数据项放入的空位置。
0xD003_7D80 --> 0xD003_7780 1.5k

1. 对于32bit的arm处理器，bootloader启动内核时,会设置r0,r1,r2三个寄存器,
r0一般设置为0;
r1一般设置为machine id (在使用设备树时该参数没有被使用);
r2一般设置ATAGS(使用设备树之前)或DTB的开始地址(使用设备树之后)

在linux内核启动之前要求如下:
①、关闭 MMU。
②、关闭 D-cache。（数据缓存)
③、 I-Cache 无所谓。(指令缓存)
④、 r0=0。
⑤、 r1=machine nr(也就是机器 ID)。
⑥、 r2=atags 或者设备树(dtb)首地址

/*
 * Kernel startup entry point.
 * MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags or dtb pointer.
 */
